#! /usr/bin/env sh
# configure
# Configuration script for `zup`.
set -e
#set -x

# Configure script parameters.
SHELL="/bin/sh"
CONFIGURE="$0"
CONFIG_STATUS="./config.status"

# Global build parameters.
EXEC_NAME=zup
EXT=sh
LOCAL_BUILD_ARTIFACTS="Makefile $CONFIG_STATUS"

usage() {
    printf "configure script for %s\n" $EXEC_NAME
    printf "\n"
    printf "%s\n" "USAGE:"
    printf "\t%s\n" "configure [OPTION] ..."
    printf "%s\n" ""
    printf "%s\n" "OPTIONS:"
    printf "\t%s\n" "--exec_prefix  ... Set executable directories prefix"
    printf "\t%s\n" "                   Default is \`/usr/local\`"
    printf "%s\n" ""
    printf "\t%s\n" "--bindir       ... Set user executable directory"
    printf "\t%s\n" "                   Default is \`<exec_prefix>/bin\`"
    printf "%s\n" ""
    printf "\t%s\n" "-h | --help  ... Show this help screen"
}

script_fail() {
    printf "*** %s : %s ***\n" "$1" "$2" >&2
    cd "$reset_dir"
    exit 2
}

# Performs initial tilde expansion on a path string.
tilde_expand() {
    expanded=
    no_tilde=${1#"~/"}
    if [ "$no_tilde" = "$1" ] ; then       # possible logname expansion
        no_tilde=${1#"~"}
        if [ "$no_tilde" =  "$1" ] ; then  # no tilde expansion to perform
            expanded="$no_tilde"
        elif [ -z "$no_tilde" ] ; then     # simple $HOME expansion
            expanded="$HOME"
        else                               # possible logname expansion
            logname=${no_tilde%%/*}
            logpath=${no_tilde#*/}
            if [ "$logpath" = "$no_tilde" ] ; then logpath='' ; fi  # no path after logname
            # Linux only:
            expanded=$(cat /etc/passwd | grep "$logname" | cut -d: -f6)
            # Fall back to unexpanded path if logname is not found.
            # Otherwise, if there is a logpath add it to the expanded logname.
            if [ -z "$expanded" ] ; then expanded="$1"
            elif ! [ -z "$logpath" ] ; then expanded="$expanded/$logpath"
            fi
        fi
    else  # Just a simple $HOME expansion.
        expanded="$HOME/$no_tilde"
    fi
    # Remove trailing slashes before printing results.
    printf '%s' "${expanded%/}"
}

# Verify dependencies.

# Parse script options.
EXEC_PREFIX=/usr/local  # executable directories prefix
BINDIR=                 # user executable directory

# Check long options for required arguments.
require_arg() {
    if [ -z "$OPTARG" ] ; then
        script_fail "Argument required" "--$OPT"
    fi
}

while getopts h-: OPT
do
    if [ $OPT = "-" ]  ; then
        OPT=${OPTARG%%=*}      # get long option
        OPTARG=${OPTARG#$OPT}  # get long option argument
        OPTARG=${OPTARG#=}
    fi
    case "$OPT" in
        exec_prefix )
            require_arg
            EXEC_PREFIX=$(tilde_expand "$OPTARG")
            ;;
        bindir )
            require_arg
            BINDIR=$(tilde_expand "$OPTARG")
            ;;
        h | help )
            usage
            exit 0 ;;
        \?)
            usage
            exit 2 ;;  # short option fail reported by `getopts`
        *)
            script_fail "Unrecognized option" "--$OPT" ;;  # long option fail
    esac
done

# Set dependent options if not set by user.
if [ -z "$BINDIR" ] ; then
    BINDIR="$EXEC_PREFIX"/bin  # user executable directory
fi

# Create `config.status` file.
touch "$CONFIG_STATUS"
cat <<_CSEOF > "$CONFIG_STATUS"
#! $SHELL
# Generated by $CONFIGURE.
# Run this file to recreate the current configuration.

# Create Makefile from template.
awk \
'NR == 1 { print "# This Makefile was generated automatically by $CONFIGURE." } ;\
/.*=@shell/ { sub(/@shell/, "${SHELL}") ; print ; next } ;\
/.*=@bindir/ { sub(/@bindir/, "${BINDIR}") ; print ; next } ;\
/.*=@exec_name/ { sub(/@exec_name/, "${EXEC_NAME}") ; print ; next } ;\
/.*=@ext/ { sub(/@ext/, "${EXT}") ; print ; next } ;\
/.*=@local_build_artifacts/ { sub(/@local_build_artifacts/, "${LOCAL_BUILD_ARTIFACTS}") ; print ; next} ;\
NR > 1 { print }' Makefile.in > Makefile
_CSEOF

$SHELL $CONFIG_STATUS
